<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Vertical Pong</title>
  <style>
    body {
      margin: 0;
      background: #f0f0f0;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      overflow: hidden;
      font-family: sans-serif;
    }
    /* when gameplay starts, pin content to the top so the full canvas is visible */
    body.playing {
      align-items: flex-start;
      padding-top: 12px; /* small spacing from top */
    }
    canvas {
      background: #fff;
      border: 2px solid #333;
      display: none;
    }
    #menu {
      text-align: center;
    }
    .character-select {
      margin: 10px 0;
    }
    .character-select img {
      width: 100px;
      height: 100px;
      margin: 5px;
      border: 3px solid transparent;
      border-radius: 8px;
      cursor: pointer;
      transition: border 0.2s;
    }
    .character-select img.selected {
      border: 3px solid #333;
    }
    button {
      padding: 10px 20px;
      font-size: 18px;
      border-radius: 8px;
      border: none;
      background: #333;
      color: #fff;
      cursor: pointer;
      margin: 5px;
    }
  </style>
</head>
<body>
    <div id="menu">
    
    <div style="text-align: center; margin: 20px 0;">
      <img src="../images/pong.png" alt="Bows & Bombs" style="width: 200px; height: auto; max-width: 100%;">
    </div>
    
    <div class="character-select">
      <p>Player 1:</p>
      <div id="bottomChoices"></div>
    </div>
    <div class="character-select">
      <p>Player 2:</p>
      <div id="topChoices"></div>
    </div>

    <div>
      <label>
        <input type="radio" name="mode" value="1" checked> 1 Player (vs AI)
      </label>
      <label>
        <input type="radio" name="mode" value="2"> 2 Players
      </label>
    </div>

    <button id="startBtn">Play</button>
  </div>

  <canvas id="gameCanvas" width="400" height="700"></canvas>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    const menu = document.getElementById("menu");
    const startBtn = document.getElementById("startBtn");
    const bottomChoices = document.getElementById("bottomChoices");
    const topChoices = document.getElementById("topChoices");

    // Example characters (replace with your own images/paths)
    const characters = [
      "images/player1.png",
      "images/player2.png",
      "images/player3.png"
    ];
    // Friendly display names matching the characters array
    const characterNames = ["Hello Kitty", "Labubu", "Kuromi"];

  let bottomImg = null;
  let topImg = null;
  // store which index was selected so we can show names
  let bottomIndex = null;
  let topIndex = null;
    let mode = 1; // default = 1 player

    function createCharacterChoices(container, callback, setIndex) {
      characters.forEach((src, idx) => {
        const img = new Image();
        img.src = src;
        img.addEventListener("click", () => {
          // Clear selection
          container.querySelectorAll("img").forEach(i => i.classList.remove("selected"));
          img.classList.add("selected");
          setIndex(idx);
          callback(img);
          // update name display if present
          const nameEl = container.parentElement.querySelector('.selected-name');
          if (nameEl) nameEl.textContent = characterNames[idx];
        });
        container.appendChild(img);
      });
    }

  // inject small name labels under each choice group
  const bottomLabel = document.createElement('div');
  bottomLabel.className = 'selected-name';
  bottomChoices.parentElement.appendChild(bottomLabel);
  const topLabel = document.createElement('div');
  topLabel.className = 'selected-name';
  topChoices.parentElement.appendChild(topLabel);

  createCharacterChoices(bottomChoices, img => bottomImg = img, idx => bottomIndex = idx);
  createCharacterChoices(topChoices, img => topImg = img, idx => topIndex = idx);

  // Make canvas responsive so the bottom player stays visible on small viewports
  // gameWidth/gameHeight are the CSS pixel sizes used for game logic
  let gameWidth = 400, gameHeight = 700;
  function resizeCanvas() {
      // original design size
      const designW = 400, designH = 700;
      // leave a small margin so controls/menu remain visible
      const maxAvailableH = Math.max(200, window.innerHeight - 40);
      const targetH = Math.min(designH, maxAvailableH);
      const aspect = designW / designH;
      const targetW = Math.round(targetH * aspect);

  // set the CSS size
  canvas.style.width = targetW + 'px';
  canvas.style.height = targetH + 'px';

  // expose CSS pixel size for game logic
  gameWidth = targetW;
  gameHeight = targetH;

      // handle devicePixelRatio so canvas is crisp on high-DPI displays
      const dpr = window.devicePixelRatio || 1;
  canvas.width = Math.round(targetW * dpr);
  canvas.height = Math.round(targetH * dpr);
      // scale the drawing context so 1 unit = 1 CSS pixel
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    // Update canvas size on window resize so the bottom paddle remains on-screen
    window.addEventListener('resize', () => {
      const wasRunning = canvas.style.display === 'block';
      resizeCanvas();
      // if game visible, reposition paddles to use new dimensions
      if (wasRunning) resetGame();
    });

    // initialize to a reasonable size
    resizeCanvas();

  // Game objects
  const paddleWidth = 80, paddleHeight = 15;
  // visualScale controls how much larger character images are drawn compared to the collision paddle.
  // Keep collisions unchanged; increase this number to make images bigger (2.5 - 3 is a good range).
  const visualScale = 3;
  // hitMargin expands the horizontal collision tolerance so paddles don't need perfect alignment
  // Increase slightly for easier hits; try values like 8-20. Lower values = less forgiving.
  const hitMargin = .000001;
  // AI tuning knobs
  // reactionDelay: number of frames the AI waits between reacting (higher = more sluggish)
  const aiReactionDelay = 0; // 0 = react every frame; try 4-8 for noticeable delay
  // randomAimOffset: maximum random horizontal offset (pixels) added to AI target to simulate mistakes
  const randomAimOffset = 18; // try 0 (perfect) up to ~30 for sloppier AI
  let aiFrameCounter = 0;
    const ballSize = 20;
    let playerPaddle, aiPaddle, ball, playerScore, aiScore;
    let keys = {};

    function resetGame() {
      playerPaddle = { x: gameWidth/2 - paddleWidth/2, y: gameHeight - 30 };
      aiPaddle = { x: gameWidth/2 - paddleWidth/2, y: 15 };
      ball = { x: gameWidth/2, y: gameHeight/2, dx: 3, dy: 3 };
      playerScore = 0;
      aiScore = 0;
    }

    function drawPaddle(paddle, img, rotate180 = false) {
      if (img) {
        // Preserve image aspect ratio but draw the image larger than the collision box.
        const aspect = img.naturalWidth && img.naturalHeight ? img.naturalWidth / img.naturalHeight : 1;
        // Desired visual height (bigger than paddleHeight)
        let drawH = paddleHeight * visualScale;
        let drawW = drawH * aspect;

        // Cap visual width so images never become absurdly large on wide canvases
  const maxVisualW = Math.min(gameWidth * 0.5, paddleWidth * 4);
        if (drawW > maxVisualW) {
          drawW = maxVisualW;
          drawH = drawW / aspect;
        }

        // Center the visual image on the paddle's center while keeping collision size unchanged.
        const drawX = paddle.x + (paddleWidth - drawW) / 2;
        const drawY = paddle.y + (paddleHeight - drawH) / 2;
        if (rotate180) {
          // draw rotated about the center of the visual image
          const cx = drawX + drawW/2;
          const cy = drawY + drawH/2;
          ctx.save();
          ctx.translate(cx, cy);
          ctx.rotate(Math.PI);
          ctx.drawImage(img, -drawW/2, -drawH/2, drawW, drawH);
          ctx.restore();
        } else {
          ctx.drawImage(img, drawX, drawY, drawW, drawH);
        }
      } else {
        ctx.fillStyle = "#333";
        ctx.fillRect(paddle.x, paddle.y, paddleWidth, paddleHeight);
      }
    }

    function drawBall() {
      ctx.beginPath();
      ctx.arc(ball.x + ballSize/2, ball.y + ballSize/2, ballSize/2, 0, Math.PI*2);
      ctx.fillStyle = "#e74c3c";
      ctx.fill();
      ctx.closePath();
    }

    function drawScores() {
      ctx.fillStyle = "#000";
      ctx.font = "20px Arial";
      const bottomName = (bottomIndex !== null && characterNames[bottomIndex]) ? characterNames[bottomIndex] : 'Bottom';
      const topName = (topIndex !== null && characterNames[topIndex]) ? characterNames[topIndex] : 'Top';
      ctx.fillText(bottomName + ": " + playerScore, 10, gameHeight - 10);
      ctx.fillText(topName + ": " + aiScore, 10, 25);
    }

    function update() {
      // --- Bottom Paddle Controls ---
      if (keys["ArrowLeft"]) playerPaddle.x -= 5;
      if (keys["ArrowRight"]) playerPaddle.x += 5;
  playerPaddle.x = Math.max(0, Math.min(gameWidth - paddleWidth, playerPaddle.x));

      // Mobile bottom paddle: tap-to-move handler (attached once)

    // --- Top Paddle Controls ---
      if (mode === 1) {
        // AI follows ball with optional reaction delay and small random aiming error
        aiFrameCounter++;
        if (aiFrameCounter > aiReactionDelay) {
          aiFrameCounter = 0;
          // compute a noisy target x (center of the ball plus a random offset)
          const noisyTarget = (ball.x + ballSize/2) + (Math.random() * 2 - 1) * randomAimOffset;
          const aiCenter = aiPaddle.x + paddleWidth/2;
          const step = 3; // AI movement per update (tweakable)
          if (noisyTarget < aiCenter) aiPaddle.x -= step;
          if (noisyTarget > aiCenter) aiPaddle.x += step;
        }
      } else {
        // Player 2: A/D keys
        if (keys["a"] || keys["A"]) aiPaddle.x -= 5;
        if (keys["d"] || keys["D"]) aiPaddle.x += 5;
      }
  aiPaddle.x = Math.max(0, Math.min(gameWidth - paddleWidth, aiPaddle.x));

      // Ball movement
      ball.x += ball.dx;
      ball.y += ball.dy;

  if (ball.x <= 0 || ball.x + ballSize >= gameWidth) ball.dx *= -1;

      // Paddle collisions
      // use ball center and a small horizontal margin for more forgiving collisions
      const ballCenterX = ball.x + ballSize/2;
      if (ball.y + ballSize >= playerPaddle.y &&
          ballCenterX > (playerPaddle.x - hitMargin) &&
          ballCenterX < (playerPaddle.x + paddleWidth + hitMargin)) {
        ball.dy *= -1;
        ball.y = playerPaddle.y - ballSize;
      }
      const ballCenterX2 = ball.x + ballSize/2;
      if (ball.y <= aiPaddle.y + paddleHeight &&
          ballCenterX2 > (aiPaddle.x - hitMargin) &&
          ballCenterX2 < (aiPaddle.x + paddleWidth + hitMargin)) {
        ball.dy *= -1;
        ball.y = aiPaddle.y + paddleHeight;
      }

      // Scoring
      if (ball.y < 0) {
        playerScore++;
        ball = { x: gameWidth/2, y: gameHeight/2, dx: 3, dy: 3 };
      } else if (ball.y > gameHeight) {
        aiScore++;
        ball = { x: gameWidth/2, y: gameHeight/2, dx: -3, dy: -3 };
      }
    }

    function draw() {
      ctx.clearRect(0, 0, gameWidth, gameHeight);
  drawPaddle(playerPaddle, bottomImg, false);
  // in 2-player mode draw the top player rotated 180deg for a natural look
  drawPaddle(aiPaddle, topImg, mode === 2);
      drawBall();
      drawScores();
    }

    // main game loop
    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    // attach input listeners once (not inside the game loop)
    document.addEventListener("keydown", e => keys[e.key] = true);
    document.addEventListener("keyup", e => keys[e.key] = false);

    // attach a tap-to-move handler that uses CSS pixel sizes
    // - bottom half taps move the bottom paddle (player 1)
    // - top half taps move the top paddle only in 2-player mode
    canvas.addEventListener('touchstart', function(e){
      if(!e.touches || e.touches.length === 0) return;
      // guard: if paddles haven't been initialized yet, ignore taps
      if(!playerPaddle || !aiPaddle) return;
      const rect = canvas.getBoundingClientRect();
      const touch = e.touches[0];
      const touchX = touch.clientX - rect.left; // CSS px
      const touchY = touch.clientY - rect.top;  // CSS px
      const cssWidth = rect.width; // CSS pixels
      const cssHeight = rect.height; // CSS pixels

      // Which half was tapped? (0..cssHeight)
      const tappedTopHalf = (touchY < cssHeight/2);

      // Helper to move a paddle left/right by a fixed amount and clamp within CSS width.
      function movePaddleCss(paddle, delta) {
        paddle.x += delta;
        // clamp using CSS width so visual alignment matches touch coords
        paddle.x = Math.max(0, Math.min(cssWidth - paddleWidth, paddle.x));
      }

      // If the top half was tapped and we're in 2-player mode, move the top paddle
      if (tappedTopHalf && mode === 2) {
        if (touchX < cssWidth/2) movePaddleCss(aiPaddle, -40);
        else movePaddleCss(aiPaddle, 40);
      }

      // If the bottom half was tapped, always move the bottom (player 1) paddle
      if (!tappedTopHalf) {
        if (touchX < cssWidth/2) movePaddleCss(playerPaddle, -40);
        else movePaddleCss(playerPaddle, 40);
      }

      e.preventDefault();
    }, { passive: false });

    startBtn.addEventListener("click", () => {
      const modeChoice = document.querySelector("input[name='mode']:checked").value;
      mode = parseInt(modeChoice);
      if (!bottomImg || !topImg) {
        alert("Select characters for both players!");
        return;
      }
      // pin content to the top so the bottom paddle is fully visible
      document.body.classList.add('playing');
  menu.style.display = "none";
  canvas.style.display = "block";
  // recompute sizes now that layout changed (body.playing / menu hidden)
  resizeCanvas();
  console.info('Play pressed — gameWidth=', gameWidth, 'gameHeight=', gameHeight);
  resetGame();
  gameLoop();
    });
  </script>
</body>
</html>


